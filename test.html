<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title></title>
</head>

<body>

<ul class="test-results"></ul>

<script type="text/javascript" src="./Future.js"></script>

<script type="text/javascript">
	
	var futureCounts = 0,
		
		ul = document.querySelector("ul.test-results"),
		
		CONST = {			
			FUTURE_CLASS_NAME : "_cls_Future",
			SWEAR_CLASS_NAME : "_cls_Future_Swear"
		},
		
		util = {
			
			isFuture : function (f) {
				return f instanceof Object && typeof f.constructor == "function" && f.constructor.name === CONST.FUTURE_CLASS_NAME;
			},
			
			isSwear : function (s) {
				return s instanceof Object && typeof s.constructor == "function" && s.constructor.name === CONST.SWEAR_CLASS_NAME;
			},
			
			cleanFuture : function () {		
				for (var i = 0; i < futureCounts; i++) {
					Future.rmOne("f" + i);
				}
			}			
		},
		
		smokeTests = {
			
			tests : [],
			
			add : function (tag, test) {				
				if (typeof test == "function") {
					test._tag = tag;
					this.tests.push(test);
				}
			},
			
			run : function () {
				
				var base = document.createElement("li");
				base.className = "test-results-result";
				
				var li;
				
				for (var i = 0; i < this.tests.length; i++) {
					
					li = base.cloneNode(true);
					li.innerHTML = "TEST :&nbsp;&nbsp;" + this.tests[i]._tag;
					try {
						li._errMsg = this.tests[i]();
					} catch(e) {
						li._errMsg = e.toString() + "<br/>&nbsp;&nbsp;&nbsp;&nbsp;" + e.stack;
					}
					if (li._errMsg !== true) {					
						li.className += " error";
						li.style.cssText = "color: red;";
						if (typeof li._errMsg === "string") {
							li.innerHTML += "<br/>" + li._errMsg;
						}						
					}
					
					ul.appendChild(li);
				}
			}
		};	
	
	smokeTests.add("New future", function () {		
		var n = "f" + futureCounts++,
			f = Future.newOne(n);		
		return util.isFuture(f);
	});
	
	smokeTests.add("Double new future", function () {			
		var n = "f" + futureCounts++,
			f0 = Future.newOne(n),
			f1 = Future.newOne(n);		
		return f0 === f1;
	});
	
	smokeTests.add("Future Exist", function () {
		var n = "f" + futureCounts++;
			Future.newOne(n);
		return Future.exist(n);
	});
	
	smokeTests.add("Remove future", function () {
		var n = "f" + futureCounts++,
			f0 = Future.newOne(n),
			f1 = Future.rmOne(n);
		return !Future.exist(n) && f0 === f1;
	});
	
	smokeTests.add("Get future name", function () {
		var i, n = [], f = [];
				
		for (i = 0; i < 3; i++) {
			n[i] = "f" + futureCounts++;
			f[i] = Future.newOne(n[i]);
		}
		
		for (i = 0; i < n.length; i++) {
			if (f[i].getName() !== n[i]) {
				return "The expected future name:" + n[i] + "but the actual future name" + f[i].getName();
			}
		}
		return true;
	});
	
	smokeTests.add("Chain futures", function () {		
		var f = Future.newOne("f" + futureCounts++);
		
		f = f.next(function() {});
		if (util.isFuture(f)) {
		
			f = f.next(function() {});
			if (util.isFuture(f)) {
			
				f = f.fall(function() {});
				if (util.isFuture(f)) {
				
					f = f.fall(function() {});
					if (util.isFuture(f)) {
					
						f = f.next(function() {});
						if (util.isFuture(f)) {
						
							return true;
						}
					}
				}
			}
		}
		
		return false;
	});
	
	smokeTests.add("Settle OK future", function () {		
		var count = 0,
			f = Future.newOne("f" + futureCounts++);
		
		f.next(function(num) { count += num; })
		 .next(function(num) { count += num; })
		 .fall(function(num) { count -= num; })
		 .fall(function(num) { count -= num; })
		 .next(function(num) { count += num; })
		 .settleOK([1]);
		
		if (count !== 3) {
			return "The expected count = 3 but the actual count = " + count;
		}
		return true;
	});
	
	smokeTests.add("Settle error future", function () {		
		var count = 0,
			f = Future.newOne("f" + futureCounts++);
		
		f.next(function(num) { count += num; })
		 .next(function(num) { count += num; })
		 .fall(function(num) { count -= num; })
		 .fall(function(num) { count -= num; })
		 .next(function(num) { count += num; })
		 .settleERR(1);
		
		if (count !== -2) {
			return "The expected count = -2 but the actual count = " + count;
		}
		return true;
	});
	
	smokeTests.add("Report future", function () {
		var f0 = Future.newOne("f" + futureCounts++),
			f1 = Future.newOne("f" + futureCounts++),
			f2 = Future.newOne("f" + futureCounts++);
		
		f0.settleOK();
		if (f0.report() != Future.FLAG_FUTURE_IS_OK) {
			return false;	
			f0.settleERR();
			if (f0.report() != Future.FLAG_FUTURE_IS_OK) {
				return false;
			}
		}
		
		f1.settleERR();
		if (f1.report() != Future.FLAG_FUTURE_IS_ERR) {
			return false;
			f1.settleOK();
			if (f1.report() != Future.FLAG_FUTURE_IS_ERR) {
				return false;
			}
		}
		
		if (f2.report() != Future.FLAG_FUTURE_NOT_YET) {
			return false;
			f2.settleOK();
			if (f2.report() != Future.FLAG_FUTURE_IS_OK) {
				return false;
			}
		}
		
		return true;
	});
	
	smokeTests.add("Dump futures", function () {
		
		util.cleanFuture();
		
		var dumps,
			token = "    ",
			f0 = Future.newOne("f" + futureCounts++),
			f1 = Future.newOne("f" + futureCounts++),
			f2 = Future.newOne("f" + futureCounts++),
			f3 = Future.newOne("f" + futureCounts++),
			f4 = Future.newOne("f" + futureCounts++),
			f5 = Future.newOne("f" + futureCounts++);
		
		f0.settleOK();
		f1.settleOK();
		f2.settleERR();
		f3.settleERR();
			
		dumps = Future.dump();
		if (dumps.length !== 0) return false;
		
		dumps = Future.dump(true);
		if (dumps.length !== 0) return false;
		
		dumps = Future.dump(Future.FLAG_FUTURE_IS_OK);
		if ([ f0.getName(), f1.getName() ].join(token) !== dumps.join(token)) return false;
		
		dumps = Future.dump(Future.FLAG_FUTURE_IS_ERR);
		if ([ f2.getName(), f3.getName() ].join(token) !== dumps.join(token)) return false;		
		
		dumps = Future.dump(Future.FLAG_FUTURE_NOT_YET);
		if ([ f4.getName(), f5.getName() ].join(token) !== dumps.join(token)) return false;
		
		return true;
	});
	
	smokeTests.add("Future and then", function () {
		
		var f = Future.newOne("f" + futureCounts++);
		
		
		
	});
	
	smokeTests.run();
	
</script>

</body>
</html>